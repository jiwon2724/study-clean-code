## 제1장. 깨끗한 코드
### 르블랑의 법칙(lebanc’s Law)
> Later equals never. 나중은 결코 오지 않는다.

빨리 가는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

우리는 다양한 이유로 안 돌아가는 프로그램보다 돌아가는 쓰레기가 낫다며, 다시 돌아와 나중에 정리하겠다고는 한다.

하지만 나중은 결코 오지 않으며, 나쁜 코드는 나쁜 코드를 유혹한다.

간단한 변경은 없으며, 얽히고설킨 코드를 '해독'해서 얽히고설킨 코드를 더하게 되며 결과적으로 팀 생산성의 하락을 야기한다.

### 깨끗한 코드란?

**비야네 스트롭스트룹,** C++ 창시자

> 우아하고 깨끗한 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다.

- CPU 자원을 낭비하지 않는 코드
- 철저한 오류 처리
- 각 함수, 클래스, 모듈은 하나에 집중한다.

*깨진 창문 이론: 나쁜 코드는 나쁜 코드를 ‘유혹’한다.*

**그래디 부치**

> 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.

- 가독성
- 추측이 아닌 사실에 기반한 코드
- 반드시 필요한 내용만 담아야 한다.

**큰 데이브 토마스**

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.

- 다른 사람이 고치기 쉬운 코드
- 읽기 쉬운 코드 ≠ 고치기 쉬운 코드
- 아무리 코드가 우아해도, 아무리 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않다.
- 작을 수록 좋다.
- ‘문학적이다’ == 인간이 읽기 좋은 코드를 작성하라

**마이클 페더스**

> 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로. 고칠 궁리를 하다 보면 언제나 제자리로 돌아온다. 그리고는 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.

- 주의 깊게 작성한 코드 
- 시간을 들여 깔끔하고 단정하게 정리한 코드 
- 세세한 사항까지 꼼꼼하게 신경 쓴 코드

**론 제프리스**
> - *모든 테스트를 통과한다.*
> - *중복이 없다.*
> - *시스템 내 모든 설계 아이디어를 표현한다.*
> - *클래스, 메서드, 함수 등을 최대한 줄인다.*
> - *표현력 높이기*
> - *초반부터 간단한 추상화 고려하기*

> 중복에 집중. 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. 
> 
> 표현력은 의미있는 이름을 포함한다. 이름을 여러 차례 바꾼다. 객체나 여러 기능을 수행한다면 여러 객체로 나누고, 메서드는 Extract Method Refactoring 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 실제로 수행하는 메서드 여러 개로 나눈다. 즉, 한 기능만 수행해라.
중복과 표현력만 신경 써도 깨끗한 코드라는 목표에 성큼 다가선다.
> 
>모든 프로그램이 아주 유사한 요소로 이루어진다. 한 가지 예가 `집합에서 항목찾기`이다. 추상 클래스나 추상 메서드를 만들어 실제 구현을 감싼다. 실제 기능은 아주 간단한 방식으로 (ex. hashmap) 구현한다. 다른 코드는 추상 클래스나 추상 메서드가 제공하는 기능을 사용하므로 실제 구현은 언제든 바꿔도 괜찮다.

- `중복 줄이기` - `표현력 높이기` - `초반부터 간단한 추상화 고려`
- 객체가 여러 기능을 수행한다면 여러 객체로 나눈다. 
- 메서드가 여러 기능을 수행한다면 메서드 추출 리팩터링 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.

**워드 커닝햄**

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.

- 읽으면서 놀랄 일이 없어야 한다. 
- 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 
- 언어를 단순하게 보이도록 만드는 책임이 우리에게 있다.


### 그렇다면 우리는

좋은 코드와 나쁜 코드를 구분할 수 있는 '**코드 감각**'을 길러야 한다.

**깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스**

- **새 코드를 짜면서 우리는 끊임 없이 기존 코드를 읽으므로**, 읽기 쉬운 코드는 매우 중요하다.
- 변수 이름 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if 문 하나를 정리하는 것부터 시작하자
- 시간이 지날수록 코드가 좋아지는 프로젝트를 만들어가야 한다.

### 느낀 점
나쁜 코드를 보면 고치고 싶은 욕구가 생기지만, 끝도 없이 연결된 모듈을 확인하면 그대로 손을 떼게 되고는 한다.

그렇게 그 위에 똑같이 나쁜 코드를 양산하면서 죄책감과 좌절감을 느끼곤 하는데, 이를 해결할 수 있는 실마리를 발견한 기분이다.

첫째, 언어 탓을 하지 말 것

둘째, 한꺼번에 고치려고 하지 말고, 처음 왔을 때보다 조금이라도 깨끗한 코드로 정리할 것